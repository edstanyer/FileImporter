using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using NRG.Models;
using System.Windows.Forms;
using System.Drawing;
using System.Collections;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using System.ComponentModel;
using System.Globalization;

namespace NRG.Native
{

	public  class NRGFile
	{

		public static class FileConstants
		{
			public static char COMMA = ',';
			public static char EQUALS = '=';
			public static char SPACE = ' ';


			public const string  HEADERSTART = "[HEADER/]";
			public const string HEADEREND = "[/HEADER]";

			public const string LAYERSSTART = "[LAYERS/]";
			public const string LAYERSEND = "[/LAYERS]";

			public const string POINTSSTART = "[POINTS/]";
			public const string POINTSEND = "[/POINTS]";

			public const string TRIANGLESSTART = "[TRIANGLES/]";
			public const string TRIANGLESEND = "[/TRIANGLES]";

			public const string SURFACESSTART = "[SURFACES/]";
			public const string SURFACESEND = "[/SURFACES]";

			public const string PRESENTATIONSTART = "[PRESENTATION/]";
			public const string PRESENTATIONEND = "[/PRESENTATION]";


			public const string FEATURESTART = "[FEATURES/]";
			public const string FEATUREEND = "[/FEATURES]";

			public const string POLYLINESSTART = "[POLYLINES/]";
			public const string POLYLINESEND = "[/POLYLINES]";

			public const string STANDARDLINESSTART = "[STANDARDLINES/]";
			public const string STANDARDINESEND = "[/STANDARDLINES]";

			public const string BLOCKDEFINITIONSSTART = "[BLOCK DEFINITIONS/]";
			public const string BLOCKDEFINITIONSEND = "[/BLOCK DEFINITIONS]";

			public const string BLOCKINSERTSSTART = "[BLOCK INSERTS/]";
			public const string BLOCKINSERTSEND = "[/BLOCK INSERTS]";

			public const string SECTIONTERMINATOR = "[/";
		}

		public class NRGFileHeader
		{ 
			public string User { get; set;}							//Not sure how this is going to work yet
			public string Date { get { return DateAndTimeFormatter(); } set { Date = value;}} 	//last file save date
			public string Contract { get; set;}						//general name for the stuff you're working on - eg M6 Smart Motorway Section 4
			public string Project4Projection { get; set; }			//change from string when proj4 is included in solution
			public Point3D SiteShift { get; set; }                  //site shift for whichever projection is selected - by default obviously 0,0,0

			private string DateAndTimeFormatter()
			{
				DateTime localDate = DateTime.Now;

				var culture = new CultureInfo("en-GB");
				string dt = localDate.ToString(culture);

				return dt;
			}
			public void WriteHeader(StreamWriter filewriter)
			{

				if (filewriter != null)
				{
					filewriter.WriteLine(FileConstants.HEADERSTART);
					//filewriter.WriteLine("{");
					filewriter.WriteLine("//File generated by NRG Surveys Software - www.nrgsurveys.co.uk");
					filewriter.WriteLine("//Important Notes:");
					filewriter.WriteLine("//All cartesian coordinates are ordered as easting, northing, level (or XYZ) ALWAYS");
					filewriter.WriteLine("//All terrestrial polar observations are ordered as horizontal reading, vertical reading, slope distance (unless otherwise specified)");
					filewriter.WriteLine("//All non-terrestrial observations (ie GNSS) are ordered as latitude, longitude, elevation");
					filewriter.WriteLine("//Site scale factor is considered as 1 unless otherwise specified.");

					filewriter.WriteLine("//Site shift is considered and applied from the origin of the selected UTM (Universal Transverse Mercator) projection");

					filewriter.WriteLine("//Any line of text (terminated with CRLF (carriage return, line feed)) in this file maybe ignored if it's prefixed with double forward slashes //");


					filewriter.WriteLine("User=" + this.User);
					filewriter.WriteLine("Date=" + this.Date);
					filewriter.WriteLine("Project=" + this.Contract);
					if (this.Project4Projection != null)
					{
						string str = this.Project4Projection.ToString();

						if (str == null || str == "") { str = "27700"; } //OSGB by default
						filewriter.WriteLine("EPSG=" + str);
					}
					Point3D ss = this.SiteShift;
					if (ss == null) { ss = new Point3D(0,0,0); }
					filewriter.WriteLine("Site Shift=" + ss.X.ToString() + FileConstants.COMMA + ss.Y.ToString() + FileConstants.COMMA + ss.Z.ToString());
					filewriter.WriteLine(FileConstants.HEADEREND);
				}
			}

			public  string ReadHeader(StreamReader filereader)
			{
				if (filereader != null)
				{
					string str = "";
					do
					{
						str = NRGFileHelper.TrimLine(filereader.ReadLine());    //if the line is a comment an empty string is returned
						if (str != null && str != "")//null reference check added in case I change my mind
						{
							string[] arr = str.Split('=');

							if (arr.Length > 1)
							{
								string FieldName = arr[0];
								string val = arr[1];
								//The following should be totally scalable, so don't fuck about with it if you don't understand what's going on...
								if (FieldName != null && FieldName != "" && val != null && val != "")
								{
									//Not commenting this shit because I hope it's obvious
									if (FieldName == "USER")
									{
										this.User = val;
									}
									else if (FieldName == "DATE")
									{
										this.Date = val;
									}
									else if (FieldName == "CONTRACT")
									{
										this.Contract = val;
									}
									else if (FieldName == "EPSG")
									{
										this.Project4Projection = val;
									}
									else if (FieldName == "SITE SHIFT")
									{
										string[] arr2 = val.Split(',');
										if (arr2 != null && arr2.Length >= 3)
										{
											double xshift, yshift, zshift;
											if (double.TryParse(arr2[0], out xshift))
											{
												if (double.TryParse(arr2[1], out yshift))
												{
													if (double.TryParse(arr2[2], out zshift))
													{
														//simple shift from UTM origin
														this.SiteShift = new Point3D(xshift, yshift, zshift);
													}

												}
											}
											
										}
									}

									//Meta data section still needs adding

								}
							}
						}
					} while (str != FileConstants.HEADEREND);
				
				}
				return "";
			}

		}

		public static class NRGFileHelper
		{
			/// <summary>
			/// Pass in a string - If it has double forward slashes retun an empty string - as these are considered as comments. (Oh and it fucks empty string off also - WIP)
			/// </summary>
			/// <param name="Input"></param>
			/// <returns></returns>
			public static string TrimLine(string Input)
			{
				string workingstring = Input.ToUpper();
				if (workingstring.Trim() != "")
				{
					if (workingstring.Contains("//")) //there's no need for this, but I'm keeping it for the time being (for reasons only known to myself).
					{ return ""; }
					else
					{
						return Input.Trim();
					}
				}

				return "";
			}
		}

		public class NRGRead
		{
			public DTM ReadFile(string filename)
			{
				if (filename == null || filename == "" || File.Exists(filename) == false)
				{
					OpenFileDialog dlg = new OpenFileDialog();

					dlg.Filter = "NRG Model Files | *.NRG";
					dlg.ShowDialog();
					if (dlg.FileName == null || dlg.FileName == "")
					{
						filename = dlg.FileName;
					}
				}
				if (File.Exists(filename) == false)
				{
					return null;
				}


				StreamReader filereader = new StreamReader(filename);

				DTM modeltoopen = new DTM();
				modeltoopen.FilePath = filename;
				modeltoopen.Name = Path.GetFileName(filename);

				List<string> PointsList = new List<string>();
				List<string> TrianglesList = new List<string>();
				List<string> LayersList = new List<string>();
				List<string> SurfaceList = new List<string>();
				List<string> FeaturesList = new List<string>();
				List<string> PolyLineList = new List<string>();
				List<string> StandardLineList = new List<string>();
				List<string> BlockDefinitionList = new List<string>();
				List<string> BlockInsertsList = new List<string>();

				while (filereader.EndOfStream == false)
				{
					string input = filereader.ReadLine();

					switch (input.ToUpper().Trim())
					{
						case "[HEADER/]":

							NRGFileHeader head = new NRGFileHeader();
							head.ReadHeader(filereader);
							break;

						case FileConstants.POINTSSTART:
							PointsList= ReadSection(filereader);
							break;
						case FileConstants.TRIANGLESSTART:
							TrianglesList = ReadSection(filereader);
							break;
						case FileConstants.LAYERSSTART:
							LayersList = ReadSection(filereader);
							break;
						case FileConstants.SURFACESSTART:
							SurfaceList = ReadSection(filereader);
							break;
						case FileConstants.FEATURESTART:
							FeaturesList = ReadSection(filereader);
							break;
						case FileConstants.POLYLINESSTART:
							PolyLineList = ReadSection(filereader);
							break;
						case FileConstants.STANDARDLINESSTART:
							StandardLineList = ReadSection(filereader);
							break;
						case FileConstants.BLOCKDEFINITIONSSTART:
							BlockDefinitionList = ReadSection(filereader);
							break;
						case FileConstants.BLOCKINSERTSSTART:
							BlockInsertsList = ReadSection(filereader);
							break;
					}

				
				}

				#region Parse Points

				BindingList<DTMPoint> dtmPointsList = ParsePoints(PointsList);
				modeltoopen.Points = dtmPointsList;
				modeltoopen.BuildPointsDictionary();
				#endregion

				#region Parse Triangle Surfaces
				List<TriangleSurface> surfaceObjList = ParseSurfaces(SurfaceList);
				modeltoopen.Surfaces = surfaceObjList;
				#endregion

				#region Parse Triangles
				HashSet<Triangle> triangleObjList = new HashSet<Triangle>(ParseTriangles(modeltoopen, TrianglesList));
				modeltoopen.Triangles = triangleObjList;
                #endregion

                #region Parse Layers
                List<DrawingLayer> layerObjList = ParseLayers(LayersList);
				
				foreach (DrawingLayer layer in layerObjList)
					modeltoopen.AddLayer(layer);
				#endregion

				#region Parse Features
				List<Feature> featureObjList = ParseFeatures(FeaturesList);
				if (modeltoopen.FeaturesDictionary != null)
					modeltoopen.FeaturesDictionary.Clear();

				var featureDict = NRG.Models.DTMHelpers.FormatFeatures(featureObjList);
		
				//this adds the FeatureDictionary to the model and interprets the codes
				modeltoopen.SetupFeaturesFromDictionary(featureDict);
				#endregion

				#region Parse Polylines
				List<PolyLine> polylineObjList = ParsePolyLines(modeltoopen, PolyLineList);
				modeltoopen.AddPolyLineList(polylineObjList);
				#endregion

				#region Parse Standard Lines
				List<StandardLine> standardlineObjList = ParseStandardLines(modeltoopen, StandardLineList);
				modeltoopen.AddStandardLineList(standardlineObjList);
				#endregion

				#region Parse BlockDefinitions
				List<BlockDefinition> blockDefinitionObjList = ParseBlockDefinitions(modeltoopen, BlockDefinitionList);
				var blockDict = modeltoopen.GetBlockDefinitionsDictionary();
				foreach(BlockDefinition block in blockDefinitionObjList)
				{
					blockDict.Add(block.Handle, block);
				}
				#endregion

				#region Parse BlockInserts
				//The block inserts get added to their respective points in this method so nothing really needs to be done here
				List<BlockInsert> blockInsertsObjList = ParseBlockInserts(modeltoopen, BlockInsertsList);
				#endregion

				return modeltoopen;
                
            }

			/// <summary>
			/// 
			/// </summary>
			/// <param name="reader"></param>
			/// <param name="sectionHeader">See "FileConstants" for correct string structure</param>
			/// <returns></returns>
            public List<string> ReadSection(StreamReader reader, string sectionHeader = null)
			{
				bool sectionFound = false;

				//If we aren't checking for a specific section, we assume the reader is already at the correct line
				if (sectionHeader == null)
					sectionFound = true;

				List<string> LinesOut = new List<string>();
				while (reader.EndOfStream == false)
				{
					string linetoread = reader.ReadLine();

					if (sectionHeader != null && linetoread.Contains(sectionHeader))
						sectionFound = true;

					if (sectionFound)
					{
						if (linetoread.Contains(FileConstants.SECTIONTERMINATOR))//check for end of section marker
						{
							return LinesOut;
						}
						else
						{
							LinesOut.Add(linetoread);
						}
					}

				}
				return LinesOut;
			}

			private BindingList<DTMPoint> ParsePoints(List<string> PointList)
            {
				BindingList<DTMPoint> dtmPointList = new BindingList<DTMPoint>();

				if (PointList == null || PointList.Count == 0) { return dtmPointList; }

				foreach (string rawPoint in PointList)
				{
					string[] arr = rawPoint.Split(FileConstants.COMMA);
					if (arr != null && arr.Length >= 5)
					{
						DTMPoint dtmPoint = new DTMPoint();

						for (int j = 0; j < arr.Length; j++)
						{
							if (j == 0) //0: ID
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.ID = Convert.ToInt32(arr[j]); }
								continue;
							}

							if (j == 1)//1: Point Number
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.PointID = arr[j]; }
								continue;
							}

							if (j == 2)//2: Easting X
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.X = Convert.ToDouble(arr[j]); }
								else { break; } //Failed to parse data, skip point
								continue;
							}

							if (j == 3)//3: Northing Y
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.Y = Convert.ToDouble(arr[j]); }
								else { break; } //Failed to parse data, skip point
								continue;
							}

							if (j == 4)//4: Level Z
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.Z = Convert.ToDouble(arr[j]); }
								else { break; } //Failed to parse data, skip point
								continue;
							}

							if (j == 5)//5: PointLabel
							{
								if (!string.IsNullOrWhiteSpace(arr[j])) { dtmPoint.PointLabel = arr[j]; }
								continue;
							}

							if (j >= 6)//Now we enter the realm of unlimited values for properties (Layers, Notes)
							{
								if (dtmPoint.ManualLayers == null) { dtmPoint.ManualLayers = new HashSet<string>(); }
								if (dtmPoint.Notes == null) { dtmPoint.Notes = new Dictionary<int, string>(); }

								if (arr[j].Contains("Layer:"))//Layers
                                {
									string[] layer = arr[j].Split(':'); //Split the string up between title of property and actual value

									if (!string.IsNullOrWhiteSpace(layer[1])) { dtmPoint.ManualLayers.Add(layer[1]); }
									continue;
								}

								if (arr[j].Contains("Note"))//Notes
                                {
									//Get Note Index
									string noteNum = arr[j].Substring(4, 1);
									//Get rid of the noteindex part
									string finalNote = arr[j].Replace(arr[j].Substring(0, 6), "");
									finalNote = finalNote.Replace("^^", ","); //Commas in the note string are replaced by ^^ in the file write
																			  //Anything leftover in finalNote is the actual note message.
									int notesIdx = 0;
									if (string.IsNullOrWhiteSpace(finalNote) || !Int32.TryParse(noteNum, out notesIdx)) { continue; } //failed to parse note 

									dtmPoint.Notes.Add(notesIdx, finalNote); //by here we should have the notes index and the related string
									continue;
								}
							}

						}

						dtmPointList.Add(dtmPoint);
					}
				}

				return dtmPointList;
			}

			private List<TriangleSurface> ParseSurfaces(List<string> SurfaceList)
            {
				List<TriangleSurface> surfaceList = new List<TriangleSurface>();

				if (SurfaceList == null | SurfaceList.Count == 0) { return surfaceList; }
				
				foreach (string rawSurface in SurfaceList)
					{
						string[] arr = rawSurface.Split(FileConstants.COMMA);
						if (arr != null && arr.Length >= 5)
						{
							TriangleSurface surface = new TriangleSurface();

							//Surface Name
							if (!string.IsNullOrWhiteSpace(arr[0]))
								surface.ID = Convert.ToInt32(arr[0]);

							//Surface Name
							if (!string.IsNullOrWhiteSpace(arr[1]))
								surface.Name = arr[1];

							//Colour
							if (!string.IsNullOrWhiteSpace(arr[2]) && int.TryParse(arr[2], out int c))
							{
								Color col = Color.FromArgb(c);

								surface.R = col.R;
								surface.G = col.G;
								surface.B = col.B;
							}

							//Dip
							if (!string.IsNullOrWhiteSpace(arr[3]))
								surface.Dip = Convert.ToDouble(arr[3]);

							//Contour
							if(!string.IsNullOrWhiteSpace(arr[4]))
								if (arr[4].ToUpper() == "FALSE") { surface.Contour = false; }

							//Volume
							if (!string.IsNullOrWhiteSpace(arr[5]))
								if (arr[5].ToUpper() == "FALSE") { surface.Contour = false; }


							surfaceList.Add(surface);
						}
					}
				
				return surfaceList;
			}

			

			private List<Triangle> ParseTriangles(DTM dtm, List<string> TriangleList)
            {
				List<Triangle> triangleList = new List<Triangle>();
				
				if (TriangleList == null || TriangleList.Count == 0) { return triangleList; }
				
				foreach (string rawTriangle in TriangleList)
					{
						string[] arr = rawTriangle.Split(FileConstants.COMMA);
						if (arr != null && arr.Length >= 10)
						{
							Triangle triangle = new Triangle();


							double x1, y1, z1, x2, y2, z2, x3, y3, z3;
							if (double.TryParse(arr[0], out x1) && double.TryParse(arr[1], out y1) && double.TryParse(arr[2], out z1) && double.TryParse(arr[3], out x2) && double.TryParse(arr[4], out y2) && double.TryParse(arr[5], out z2) && double.TryParse(arr[6], out x3) && double.TryParse(arr[7], out y3) && double.TryParse(arr[8], out z3))
							{
								DTMPoint pt1 = dtm.MatchPointFromPointsDictionary(x1, y1, z1, true, "Default", false);
								triangle.Point1 = pt1;
								DTMPoint pt2 = dtm.MatchPointFromPointsDictionary(x2, y2, z2, true, "Default", false);
								triangle.Point2 = pt2;
								DTMPoint pt3 = dtm.MatchPointFromPointsDictionary(x3, y3, z3, true, "Default", false);
								triangle.Point3 = pt3;
							}

							#region commented out shit
							//Set the default states for the triangle's properties





							//#region Point 1



							//if (!string.IsNullOrWhiteSpace(arr[0]))
							//	if (dtm.Points[Convert.ToInt32(arr[0])].ID == Convert.ToInt32(arr[0]))
							//		triangle.Point1 = dtm.Points[Convert.ToInt32(arr[0])];
							//	else
							//		foreach (var point in dtm.Points)
							//			if (point.ID == Convert.ToInt32(arr[0]))
							//				triangle.Point1 = point;
							//#endregion

							//#region Point 2
							//if (!string.IsNullOrWhiteSpace(arr[1]))
							//	if (dtm.Points[Convert.ToInt32(arr[1])].ID == Convert.ToInt32(arr[1]))
							//		triangle.Point2 = dtm.Points[Convert.ToInt32(arr[1])];
							//	else
							//		foreach (var point in dtm.Points)
							//			if (point.ID == Convert.ToInt32(arr[1]))
							//				triangle.Point2 = point;
							//#endregion

							//#region Point 3
							//if (!string.IsNullOrWhiteSpace(arr[2]))
							//	if (dtm.Points[Convert.ToInt32(arr[2])].ID == Convert.ToInt32(arr[2]))
							//		triangle.Point3 = dtm.Points[Convert.ToInt32(arr[2])];
							//	else
							//		foreach (var point in dtm.Points)
							//			if (point.ID == Convert.ToInt32(arr[2]))
							//				triangle.Point3 = point;
							////#endregion
							#endregion

							#region Surface
							if (!string.IsNullOrWhiteSpace(arr[9]))
								if (dtm.Surfaces[Convert.ToInt32(arr[9])].ID == Convert.ToInt32(arr[9]))
									triangle.Surface = dtm.Surfaces[Convert.ToInt32(arr[9])];
								else
									foreach (var surface in dtm.Surfaces)
										if (surface.ID == Convert.ToInt32(arr[9]))
											triangle.Surface = surface;
							#endregion

							if (triangle.Point1 == null || triangle.Point2 == null || triangle.Point3 == null)
								continue;

							if (triangle.Surface == null)
								triangle.Surface = dtm.Surfaces[0];

							//Sets up the many to many relationships "properly"...
							Triangle triangleToAdd = new Triangle(triangle.Surface, triangle.Point1, triangle.Point2, triangle.Point3);

							triangleList.Add(triangleToAdd);
						}
					}
				
				return triangleList;
			}

			private List<DrawingLayer> ParseLayers(List<string> LayerList)
			{
				List<DrawingLayer> layerObjList = new List<DrawingLayer>();

				if (LayerList == null || LayerList.Count == 0) { return layerObjList; }
				
				foreach (string lay in LayerList)
					{
						string[] arr = lay.Split(FileConstants.COMMA);
						if (arr != null && arr.Length >= 4)
						{
							DrawingLayer l = new DrawingLayer();
							if (arr[0] != null && arr[0] != "")
							{
								l.Name = arr[0];
								
								if (arr[1] != null && arr[1] != "" && int.TryParse(arr[1],out int c))
								{
						
									
									Color col = Color.FromArgb(c);

									l.Colour = col;
									l.Draw = true;
									l.Triangulate = true;
									if (arr[2] != null && arr[2] != "")
									{
										if (arr[2].ToUpper() == "FALSE") { l.Draw = false; }
									}
									if (arr[3] != null && arr[3] != "")
									{
										if (arr[3].ToUpper() == "FALSE") { l.Triangulate= false; }
									}
								}
							}
							layerObjList.Add(l);
						}
					}
				
				return layerObjList;
			}

			/// <summary>
			/// Parses the string items read from the section into a list of "Feature"s.
			/// </summary>
			/// <param name="FeatureList"></param>
			/// <returns></returns>
			public List<Feature> ParseFeatures(List<string> FeatureList)
            {
				List<Feature> featureObjList = new List<Feature>();

				if (FeatureList == null || FeatureList.Count == 0) { return featureObjList; }
				
				foreach (string feature in FeatureList)
					{
						string[] arr = feature.Split(FileConstants.COMMA);
						if (arr != null && arr.Length >= 5) //5 is the minimum number of fields required for a PointFeature. LineFeature requires 7. TN 31.01.22
						{
							if (!string.IsNullOrWhiteSpace(arr[0]))
							{
								if (!string.IsNullOrWhiteSpace(arr[1]))
								{
									//These two regions below (Setup point feature & Setup line feature) should be identical other than the initial object create being a LineFeature or PointFeature TN: 23.09.21
                                    
									#region Setup a Point Feature

                                    if (arr[1] == "PointFeature")
									{
										PointFeature pointFeature = new PointFeature();
										pointFeature.R = 0;
										pointFeature.FieldCode = arr[0];
										pointFeature.Code = arr[0].Replace("?", "").Replace("*", "");

										if (!string.IsNullOrWhiteSpace(arr[2]) && int.TryParse(arr[2], out int c))
										{
											Color col = Color.FromArgb(c);
											pointFeature.R = col.R;
											pointFeature.G = col.G;
											pointFeature.B = col.B;

											pointFeature.Layer = "Default";
											pointFeature.PlanFeature = "SOLID";
											pointFeature.BreakLineType = BreakLineType.BreakLine;

											if (!string.IsNullOrWhiteSpace(arr[3]))
												pointFeature.Layer = arr[3];

											if (!string.IsNullOrWhiteSpace(arr[4]))
												pointFeature.PlanFeature = arr[4];

											if (!string.IsNullOrWhiteSpace(arr[5]))
											{
												if (arr[5] == "Breakline")
													pointFeature.BreakLineType = BreakLineType.BreakLine;
												if (arr[5] == "ExcludeFromModel")
													pointFeature.BreakLineType = BreakLineType.ExcludeFromModel;
												if (arr[5] == "None")
													pointFeature.BreakLineType = BreakLineType.None;
											}
										}

										featureObjList.Add(pointFeature);
									}
									#endregion

									#region Setup a Line Feature

									if (arr[1] == "LineFeature")
									{
										LineFeature lineFeature = new LineFeature();
										lineFeature.R = lineFeature.G = lineFeature.B = 0;
										lineFeature.FieldCode = arr[0];
										lineFeature.Code = arr[0].Replace("?", "").Replace("*", "");

										//Colour
										if (!string.IsNullOrWhiteSpace(arr[2]) && int.TryParse(arr[2], out int c))
										{
											Color col = Color.FromArgb(c);
											lineFeature.R = col.R;
											lineFeature.G = col.G;
											lineFeature.B = col.B;
										}
										lineFeature.Show = true;
										lineFeature.Layer = "Default";
										lineFeature.PlanFeature = "SOLID";
										lineFeature.BreakLineType = BreakLineType.BreakLine;
										lineFeature.LineWeight = 1;

										//Layer
										if (!string.IsNullOrWhiteSpace(arr[3]))
											lineFeature.Layer = arr[3];

										//Feature Code
										if (!string.IsNullOrWhiteSpace(arr[4]))
											lineFeature.PlanFeature = arr[4];

										//Breakline Type
										if (!string.IsNullOrWhiteSpace(arr[5]))
										{
											if (arr[5] == "BreakLine")
												lineFeature.BreakLineType = BreakLineType.BreakLine;
											if (arr[5] == "ExcludeFromModel")
												lineFeature.BreakLineType = BreakLineType.ExcludeFromModel;
											if (arr[5] == "None")
												lineFeature.BreakLineType = BreakLineType.None;
										}
											
										//LineWeight
										if (arr.Length > 6 && !string.IsNullOrWhiteSpace(arr[6]))
										{
											int lw = 1;
											if (Int32.TryParse(arr[6], out lw))
											{
												lineFeature.LineWeight = lw;
											}
												
										}

										//Line Weight by Layer
										if (arr.Length > 7 && !string.IsNullOrWhiteSpace(arr[7]))
                                        {
											bool lwbyLayer = false;
											if (bool.TryParse(arr[7], out lwbyLayer))
												lineFeature.LwByLayer = lwbyLayer;
                                        }
										

										featureObjList.Add(lineFeature);
									}
									#endregion

								}
							}
							
						}
					}
				

				return featureObjList;
			}

			///// <summary>
			///// Pass a raw list of feature objects and in return recieve a fully populated Features Dictionary 
			///// </summary>
			///// <param name="FeatureList"></param>
			///// <returns></returns>
			//public Dictionary<char, List<Feature>> FormatFeatures(List<Feature> featureObjList)
			//{
			//	Dictionary<char, List<Feature>> featureDict = new Dictionary<char, List<Feature>>();
			//	foreach (Feature feature in featureObjList)
			//	{
			//		var str = feature.Code.ToCharArray();

			//		if (featureDict.ContainsKey(str[0]))
			//			featureDict[str[0]].Add(feature);
			//		else
			//		{
			//			List<Feature> singleCharFeatureList = new List<Feature>();
			//			singleCharFeatureList.Add(feature);
			//			featureDict.Add(str[0], singleCharFeatureList);
			//		}
			//	}

			//	//this step below does a "test-run" of setting up the features so they are formatted appropriatley and duplicates are handled.
			//	var tempDTM = new DTM();
			//	tempDTM.SetupFeaturesFromDictionary(featureDict);

			//	return tempDTM.FeaturesDictionary;

			//}
			private List<PolyLine> ParsePolyLines(DTM dtm, List<string> PolyLineList)
            {
				List<PolyLine> polyLineObjList = new List<PolyLine>();

				if (PolyLineList == null || PolyLineList.Count == 0) { return polyLineObjList; }
				
				foreach (string rawPolyLine in PolyLineList)
					{
						string[] arr = rawPolyLine.Split(FileConstants.COMMA);

						PolyLine polyline= new PolyLine();
						if (arr.Length >= 12) //minimum amount of strings for there to be at least 2 points in the polyline
						{
							//Set the default states for the polylines' properties
							polyline.AddToLayer(dtm);
							polyline.Colour = Color.Black;


							//Layer
							if (!string.IsNullOrWhiteSpace(arr[0]))
							{
								polyline.AddToLayer(dtm, arr[0]);
							}

							//Colour
							if (!string.IsNullOrWhiteSpace(arr[1]) && int.TryParse(arr[1], out int c))
							{
								polyline.Colour = Color.FromArgb(c);
							}

							//Lineweight
							if (!string.IsNullOrWhiteSpace(arr[2]) && int.TryParse(arr[2], out int lw))
							{
								polyline.Lineweight = lw;
                            }

							//Lineweight By Layer
							if (!string.IsNullOrWhiteSpace(arr[3]) && bool.TryParse(arr[3], out bool lwByLayer))
                            {
								polyline.LwByLayer = lwByLayer;
                            }

                            #region Nodes
                            if (polyline.Nodes == null)
								polyline.Nodes = new BindingList<DTMPoint>();

							int arrayIncrement = 4; //Amount of fields we read per point (ID, X, Y Z)

							for (int arrayIndex = 4; arrayIndex < arr.Length; arrayIndex += arrayIncrement) //Loop for each node, the 4 is the starting field numer (Layer 0, Colour 1, LineWeight 2, LwByLayer 3, PointID 4...)
                            {
								if (string.IsNullOrWhiteSpace(arr[arrayIndex]))
									break;

								DTMPoint bestFoundPoint = new DTMPoint();

								double x, y, z;

								if (Double.TryParse(arr[arrayIndex + 1], out x) && Double.TryParse(arr[arrayIndex + 2], out y) && Double.TryParse(arr[arrayIndex + 3], out z))
								{
									DTMPoint pt1 = dtm.MatchPointFromPointsDictionary(x, y, z, true, "Default", false);
									bestFoundPoint = pt1;
								}
								else
									break;

								polyline.Nodes.Add(bestFoundPoint);
                            }

							#endregion

							if (polyline.Nodes !=null && polyline.Nodes.Count > 1)
								polyLineObjList.Add(polyline);
							
						}
					}
				

				return polyLineObjList;
            }
			private List<StandardLine> ParseStandardLines(DTM dtm, List<string> StandardLineList)
			{
				List<StandardLine> standardLineObjList = new List<StandardLine>();

				if (StandardLineList == null && StandardLineList.Count == 0) { return standardLineObjList; }
				
				foreach (string rawStandardLine in StandardLineList)
					{
						string[] arr = rawStandardLine.Split(FileConstants.COMMA);

						StandardLine standardline = new StandardLine();
						if (arr.Length >= 12) //minimum amount of strings for there to be at least 2 points in the standardline
						{
							//Set the default states for the polylines' properties
							standardline.AddToLayer(dtm);
							standardline.Colour = Color.Black;


							//Layer
							if (!string.IsNullOrWhiteSpace(arr[0]))
							{
								standardline.AddToLayer(dtm, arr[0]);
							}

							//Colour
							if (!string.IsNullOrWhiteSpace(arr[1]) && int.TryParse(arr[1], out int c))
							{
								standardline.Colour = Color.FromArgb(c);
							}

							//Lineweight
							if (!string.IsNullOrWhiteSpace(arr[2]) && int.TryParse(arr[2], out int lw))
                            {
								standardline.Lineweight = lw;
                            }

							//Lineweight By Layer
							if (!string.IsNullOrWhiteSpace(arr[3]) && bool.TryParse(arr[3], out bool lwByLayer))
                            {
								standardline.LwByLayer = lwByLayer;
                            }
	
							#region Start and End Point
							if (standardline.StartPoint == null)
								standardline.StartPoint = new DTMPoint();

							if (standardline.EndPoint == null)
								standardline.EndPoint = new DTMPoint();

							bool isStartPoint = true;
							int arrayIncrement = 4;  //Amount of fields we read per point (ID, X, Y Z)

							for (int arrayIndex = 4; arrayIndex < arr.Length; arrayIndex += arrayIncrement) //Loop for each node, the 4 is the starting field numer (Layer 0, Colour 1, LineWeight 2, LwByLayer 3, PointID 4...)
							{

									if (string.IsNullOrWhiteSpace(arr[arrayIndex]))
										break;

								int pointIDIndex = Convert.ToInt32(arr[arrayIndex]);
								DTMPoint bestFoundPoint = new DTMPoint();
								double x, y, z;

								if (Double.TryParse(arr[arrayIndex + 1], out x) && Double.TryParse(arr[arrayIndex + 2], out y) && Double.TryParse(arr[arrayIndex + 3], out z))
								{
									DTMPoint pt1 = dtm.MatchPointFromPointsDictionary(x, y, z, true, "Default", false);
									bestFoundPoint = pt1;
								}
								else
									break;

								if (bestFoundPoint != null)
								{
									if (isStartPoint)
									{
										standardline.StartPoint = bestFoundPoint;
										isStartPoint = false;	
									}
									else
										standardline.EndPoint = bestFoundPoint;
								}
							}

							#endregion

							if (standardline.StartPoint != null && standardline.EndPoint != null)
								standardLineObjList.Add(standardline);

						}
					}
				
				return standardLineObjList;
			}
			private List<BlockDefinition> ParseBlockDefinitions(DTM dtm, List<string> BlockDefinitionList)
			{
				List<BlockDefinition> blockDefinitionsObjList = new List<BlockDefinition>();

				if (BlockDefinitionList == null && BlockDefinitionList.Count == 0) { return blockDefinitionsObjList; }

				foreach (string rawBlockDefinition in BlockDefinitionList)
					{
						string[] arr = rawBlockDefinition.Split(FileConstants.COMMA);

						BlockDefinition blockDefinition = new BlockDefinition();
						if (arr.Length >= 9) //minimum amount of strings for there to be at least 2 points in the blockdefinition's blocklines
						{
							//Block Handle
							if (!string.IsNullOrWhiteSpace(arr[0]))
							{
								blockDefinition.Handle = arr[0];
							}
							else
							{
								continue;
							}
							//Block Name
							if (!string.IsNullOrWhiteSpace(arr[1]))
							{
								blockDefinition.Name = arr[1];
							}
							else
							{
								blockDefinition.Name = blockDefinition.Handle;
							}
							//Block Lines

							#region Block Lines
							if (blockDefinition.BlockLines == null)
								blockDefinition.BlockLines = new List<BlockLine>();

							int arrayIncrement = 7;

							for (int arrayIndex = 2; arrayIndex < arr.Length; arrayIndex += arrayIncrement) //Loop for each blockline found
							{
								if (string.IsNullOrWhiteSpace(arr[arrayIndex]))
									break;

								BlockLine blockLine = new BlockLine();
								double x1, y1, z1, x2 ,y2 ,z2;

								//Start Point
								if (Double.TryParse(arr[arrayIndex], out x1) && Double.TryParse(arr[arrayIndex +1 ], out y1) && Double.TryParse(arr[arrayIndex + 2], out z1))
								{
									blockLine.StartPoint.X = x1;
									blockLine.StartPoint.Y = y1;
									blockLine.StartPoint.Z = z1;
								}
								else
								{
									break;
								}
								//End Point
								if (Double.TryParse(arr[arrayIndex + 3], out x2) && Double.TryParse(arr[arrayIndex + 4], out y2) && Double.TryParse(arr[arrayIndex + 5], out z2))
								{
									blockLine.EndPoint.X = x2;
									blockLine.EndPoint.Y = y2;
									blockLine.EndPoint.Z = z2;
								}
								else
								{
									break;
								}


								//Radius (for possible future use)
								double radius;
								if (Double.TryParse(arr[arrayIndex + 6], out radius))
								{
									blockLine.Radius = radius;
								}
								else
								{
									break;
								}

								blockDefinition.BlockLines.Add(blockLine);

							}
							#endregion

						}

						if (blockDefinition != null && blockDefinition.BlockLines.Count > 0)
							blockDefinitionsObjList.Add(blockDefinition);
					}
				
				return blockDefinitionsObjList;
			}
			private List<BlockInsert> ParseBlockInserts(DTM dtm, List<string> BlockInsertsList)
			{
				List<BlockInsert> blockInsertObjList = new List<BlockInsert>();

				if (BlockInsertsList == null || BlockInsertsList.Count == 0) { return blockInsertObjList; }
				
				foreach (string rawBlockInsert in BlockInsertsList)
					{
						string[] arr = rawBlockInsert.Split(FileConstants.COMMA);

						BlockInsert blockInsert = new BlockInsert();
						if (arr.Length >= 13) //minimum amount of strings for there to be all the necessary properties there for a block insert
						{ 
							blockInsert.AddToLayer(dtm);// Set the default states for the polylines' properties

							//Block Definition Handle
							if (!string.IsNullOrWhiteSpace(arr[0]))
							{
								blockInsert.BlockDefinitionHandle = arr[0];
							}
							else { break; }

							//Layer
							if (!string.IsNullOrWhiteSpace(arr[1]))
							{
								blockInsert.AddToLayer(dtm, arr[1]);
							}

							//Respective DTM Point
							DTMPoint bestFoundPoint = new DTMPoint();
							double x, y, z;
							if (!string.IsNullOrWhiteSpace(arr[2]) && !string.IsNullOrWhiteSpace(arr[3]) && !string.IsNullOrWhiteSpace(arr[4]) && Double.TryParse(arr[2], out x) && Double.TryParse(arr[3], out y) && Double.TryParse(arr[4], out z))
							{
								bestFoundPoint = dtm.MatchPointFromPointsDictionary(x, y, z, true, "Default", false);
								if (bestFoundPoint.BlockInserts == null) { bestFoundPoint.BlockInserts = new List<BlockInsert>();}
								bestFoundPoint.BlockInserts.Add(blockInsert);
							}
							else { break; }

							//Insertion Offset
							double x1, y1, z1;
							if (!string.IsNullOrWhiteSpace(arr[5]) && !string.IsNullOrWhiteSpace(arr[6]) && !string.IsNullOrWhiteSpace(arr[7]) && Double.TryParse(arr[5], out x1) && Double.TryParse(arr[6], out y1) && Double.TryParse(arr[7], out z1))
							{
								blockInsert.InsertionOffset.X = x1;
								blockInsert.InsertionOffset.Y = y1;
								blockInsert.InsertionOffset.Z = z1;
							}
							else { break; }

							//Scale
							double x2, y2, z2;
							if (!string.IsNullOrWhiteSpace(arr[8]) && !string.IsNullOrWhiteSpace(arr[9]) && !string.IsNullOrWhiteSpace(arr[10]) && Double.TryParse(arr[8], out x2) && Double.TryParse(arr[9], out y2) && Double.TryParse(arr[10], out z2))
							{
								blockInsert.Scale.X = x2;
								blockInsert.Scale.Y = y2;
								blockInsert.Scale.Z = z2;
							}
							else { break; }

							//Rotation
							double rotation;
							if (!string.IsNullOrWhiteSpace(arr[11]) && Double.TryParse(arr[11], out rotation))
							{
								blockInsert.Rotation = rotation;
							}
							else { break; }

							//Colour
							if (!string.IsNullOrWhiteSpace(arr[12]) && int.TryParse(arr[12], out int c))
							{
								blockInsert.Colour = Color.FromArgb(c);
							}
							else { break; }

							if (blockInsert != null && !string.IsNullOrWhiteSpace(blockInsert.BlockDefinitionHandle))
								blockInsertObjList.Add(blockInsert);

						}
					}

				return blockInsertObjList;
			}


			
			Color InttoRGB(int col)
			{

				int r = 0; int g = 0; int b = 0;

				NRG.Services.Conversions.LongIntToRGB(col, ref r, ref g, ref b);

				Color outcol =  Color.FromArgb(col);

				


				return outcol;
			}


		}

		

		/// <summary>
		/// Write NRG files
		/// more comments here please...
		/// </summary>
		public class NRGWrite
		{
			public bool PointIDSGenerated = false; //this is really simple - points need to be iterated through and model.points.id needs to allocated an index starting from 0 - if you're confused ask ES - Once the procedure is complete this flag maybe set to bool TRUE

			private void WriteLayers(DTM ModelToWrite, StreamWriter filewriter)
			{
				if (ModelToWrite.DrawingLayers == null) { return; }
				if (filewriter!= null && ModelToWrite != null)
				{

					filewriter.WriteLine(FileConstants.LAYERSSTART);
					foreach (var ly in ModelToWrite.DrawingLayers)
					{

						filewriter.WriteLine(ly.Value.Name + FileConstants.COMMA + ly.Value.Colour.ToArgb().ToString() + FileConstants.COMMA + ly.Value.Draw.ToString() + FileConstants.COMMA + ly.Value.Triangulate.ToString());
					}
					filewriter.WriteLine(FileConstants.LAYERSEND);
					filewriter.Flush();
				}
			}

			private void WriteSurfaces(DTM ModelToWrite, StreamWriter filewriter)
			{

				if (filewriter != null && ModelToWrite != null)
				{

					filewriter.WriteLine(FileConstants.SURFACESSTART);
					if (ModelToWrite.Surfaces == null || ModelToWrite.Surfaces.Count == 0)
					{
						//DTMHelpers hlp = new DTMHelpers();
						DTMHelpers.CreateBaseSurfaces(ModelToWrite);
					}
					foreach (var s in ModelToWrite.Surfaces)
					{

						Color col =  Color.FromArgb(s.R, s.G, s.B);

						filewriter.WriteLine(s.ID.ToString() + FileConstants.COMMA + s.Name + FileConstants.COMMA + col.ToArgb().ToString() + FileConstants.COMMA + s.Dip.ToString() + FileConstants.COMMA + s.Contour.ToString()  + FileConstants.COMMA + s.Volume.ToString()); 
					}
					filewriter.WriteLine(FileConstants.SURFACESEND);
					filewriter.Flush();
				}
			}

			/// <summary>
			/// Write points to file (OBVS) squirts the points from ModelToWrite out to the stream writer filewriter
			/// </summary>
			/// <param name="ModelToWrite">source model</param>
			/// <param name="filewriter">ASCII file in which to write the data/></param>
			private void WritePoints(DTM ModelToWrite, StreamWriter filewriter)
			{
				if (ModelToWrite != null && ModelToWrite.Points != null && ModelToWrite.Points.Count > 0 && filewriter != null)
				{
					int i = 0;
					filewriter.WriteLine(FileConstants.POINTSSTART);
					foreach (DTMPoint pt in ModelToWrite.Points)
					{
						//ID,PointID,X,Y,Z,PointLabel,Layer^layerName,Layer^layerName,Note# noteText,Note# noteText
						pt.ID = i;
						i++;

						if (pt.PointID == null) { pt.PointID = ""; } 
						if (pt.PointLabel == null) { pt.PointLabel = ""; }

						filewriter.Write(pt.ID.ToString() + FileConstants.COMMA + pt.PointID.ToString() + FileConstants.COMMA + pt.X.ToString() + FileConstants.COMMA + pt.Y.ToString() + FileConstants.COMMA + pt.Z.ToString() + FileConstants.COMMA + pt.PointLabel.ToString());
						 

						//Layers
						if (pt.ManualLayers != null)
                        {
							foreach(string layer in pt.ManualLayers)
                            {
								filewriter.Write(FileConstants.COMMA + "Layer:" + layer);
                            }
                        }

						//Notes
						if (pt.Notes != null)
						{
							foreach(KeyValuePair<int,string> notes in pt.Notes) 
							{

								string formattedNote = notes.Value.Replace(",", "^^"); //Swap out commas in the note for ^^ so the file read doesn't go wonky
								filewriter.Write(FileConstants.COMMA + "Note" + notes.Key.ToString() + " " + formattedNote);
							}
						}

						filewriter.Write(filewriter.NewLine);
						
					}
					PointIDSGenerated = true; //no need to call the SUB_PROC <PROC GenerateIDS> as we've done it in the above iterative loop
					filewriter.WriteLine(FileConstants.POINTSEND);
					filewriter.Flush();
				}
			}

			/// <summary>
			/// Loops through all points in a model and asigns and incremental number to each point in the DTM Input Model - needed for the SUB_PROC <PROC WriteTriangles></PROC>
			/// </summary>
			/// <param name="modeltowrite"> Input Model</param>
			private void GenerateIDS(DTM modeltowrite)
			{
				if (modeltowrite != null)
				{
					int i = 0;
					foreach (DTMPoint pt in modeltowrite.Points)
					{
						
						pt.ID = i;
						i++;
					}
					PointIDSGenerated = true;
				}
			}


			/// <summary>
			/// 
			/// </summary>
			/// <param name="ModelToWrite"></param>
			/// <param name="filewriter"></param>
			private void WriteTriangles(DTM ModelToWrite, StreamWriter filewriter)
			{
				if (ModelToWrite != null && ModelToWrite.Triangles != null && ModelToWrite.Triangles.Count > 0 && filewriter != null)
				{
					filewriter.WriteLine(FileConstants.TRIANGLESSTART);
					if (PointIDSGenerated == false) { GenerateIDS(ModelToWrite); }
					foreach (Triangle t in ModelToWrite.Triangles)
					{

 					    //filewriter.WriteLine(t.Point1.ID.ToString() + FileConstants.COMMA + t.Point2.ID.ToString() + FileConstants.COMMA + t.Point3.ID.ToString() + FileConstants.COMMA + t.Surface.ID.ToString());
						filewriter.WriteLine(t.Point1.X.ToString() + FileConstants.COMMA + t.Point1.Y.ToString() + FileConstants.COMMA + t.Point1.Z.ToString()
						+ FileConstants.COMMA + t.Point2.X.ToString() + FileConstants.COMMA + t.Point2.Y.ToString() + FileConstants.COMMA + t.Point2.Z.ToString()
						+ FileConstants.COMMA + t.Point3.X.ToString() + FileConstants.COMMA + t.Point3.Y.ToString() + FileConstants.COMMA + t.Point3.Z.ToString() + FileConstants.COMMA + t.Surface.ID.ToString());
					}
					filewriter.WriteLine(FileConstants.TRIANGLESEND);
					filewriter.Flush();

				}
			}

			public void WriteFeaturesLibrary(Dictionary<char, List<Feature>> featuresDictionary, StreamWriter filewriter)
			{
				if (featuresDictionary != null && featuresDictionary.Count > 0)
				{
					filewriter.WriteLine(FileConstants.FEATURESTART);

					featuresDictionary.ToString();


					foreach (var colect in featuresDictionary.Values)
					{
						foreach (var featureItem in colect)
						{
							string featureType = "UnknownFeatureType";
							if (featureItem.GetType().ToString() == ("NRG.Models.LineFeature"))
								featureType = "LineFeature";
							if (featureItem.GetType().ToString() == ("NRG.Models.PointFeature"))
								featureType = "PointFeature";

							Color col = Color.FromArgb(featureItem.R, featureItem.G, featureItem.B);
							filewriter.WriteLine(featureItem.FieldCode + FileConstants.COMMA + featureType + FileConstants.COMMA + col.ToArgb().ToString() + FileConstants.COMMA + featureItem.Layer + FileConstants.COMMA + featureItem.PlanFeature + FileConstants.COMMA + featureItem.BreakLineType.ToString() + FileConstants.COMMA + featureItem.LineWeight.ToString() + FileConstants.COMMA + featureItem.LwByLayer.ToString()); 

						}
					}
					filewriter.WriteLine(FileConstants.FEATUREEND);
					filewriter.Flush();
				}
			}


			private void WritePolyLines(DTM modeltowrite, StreamWriter writer)
			{
				if (modeltowrite != null)
				{
					List<PolyLine> Polys = modeltowrite.GetPolyLines();
					if (Polys.Count > 0)
					{
						writer.WriteLine(FileConstants.POLYLINESSTART);
						foreach (PolyLine p in Polys)
						{ 
																			   
							string outstring = "";
							outstring = p.Layer + FileConstants.COMMA + p.Colour.ToArgb().ToString() + FileConstants.COMMA + p.Lineweight.ToString() + FileConstants.COMMA + p.LwByLayer.ToString(); 
							foreach (DTMPoint pt in p.Nodes)
							{
								outstring += FileConstants.COMMA + pt.ID.ToString() + FileConstants.COMMA + pt.X.ToString() + FileConstants.COMMA + pt.Y.ToString() + FileConstants.COMMA + pt.Z.ToString();
							}

							writer.WriteLine(outstring);
						}
						writer.WriteLine(FileConstants.POLYLINESEND);
						writer.Flush();

					}
				}
			
			}

			private void WriteStandardLines(DTM modeltowrite, StreamWriter writer)
			{
				if (modeltowrite != null)
				{
					List<PolyLine> Polys = modeltowrite.GetPolyLines();
					if (Polys.Count > 0)
					{
						writer.WriteLine(FileConstants.STANDARDLINESSTART);
						foreach (StandardLine ln in modeltowrite.GetStandardLines())
						{

							string outstring = "";
							outstring = ln.Layer + FileConstants.COMMA + ln.Colour.ToArgb().ToString() + FileConstants.COMMA + ln.Lineweight.ToString() + FileConstants.COMMA + ln.LwByLayer.ToString() + FileConstants.COMMA + ln.StartPoint.ID.ToString() + FileConstants.COMMA + ln.StartPoint.X + FileConstants.COMMA + ln.StartPoint.Y+ FileConstants.COMMA + ln.StartPoint.Z + FileConstants.COMMA + ln.EndPoint.ID + FileConstants.COMMA + ln.EndPoint.X + FileConstants.COMMA + ln.EndPoint.Y + FileConstants.COMMA + ln.EndPoint.Z;
							writer.WriteLine(outstring);
						}
						writer.WriteLine(FileConstants.STANDARDINESEND);
						writer.Flush();

					}
				}

			}

			private void WriteBlockDefinitions(DTM modeltowrite, StreamWriter writer)
			{
				if (modeltowrite != null)
				{
					var blockDefinitionDictionary = modeltowrite.GetBlockDefinitionsDictionary();
					if (blockDefinitionDictionary.Count > 0)
					{
						writer.WriteLine(FileConstants.BLOCKDEFINITIONSSTART);
						foreach (BlockDefinition bd in blockDefinitionDictionary.Values)
						{

							string outstring = "";
							outstring = bd.Handle + FileConstants.COMMA + bd.Name;
							
							foreach(var bl in bd.BlockLines)
							{
								outstring += FileConstants.COMMA + bl.StartPoint.X.ToString() + FileConstants.COMMA + bl.StartPoint.Y.ToString() + FileConstants.COMMA + bl.StartPoint.Z.ToString();
								outstring += FileConstants.COMMA + bl.EndPoint.X.ToString() + FileConstants.COMMA + bl.EndPoint.Y.ToString() + FileConstants.COMMA + bl.EndPoint.Z.ToString();
								outstring += FileConstants.COMMA + bl.Radius.ToString();

							}

							writer.WriteLine(outstring);
						}
						writer.WriteLine(FileConstants.BLOCKDEFINITIONSEND);
						writer.Flush();

					}
				}
			}

			private void WriteBlockInserts(DTM modeltowrite, StreamWriter writer)
			{
				if (modeltowrite != null && modeltowrite.Points != null && modeltowrite.Points.Count > 0)
				{
					writer.WriteLine(FileConstants.BLOCKINSERTSSTART);
					foreach (DTMPoint point in modeltowrite.Points)
					{
						if (point.BlockInserts != null && point.BlockInserts.Count > 0)
						{
							foreach (BlockInsert bi in point.BlockInserts)
							{

								string outstring = "";
								//Basic Info
								outstring = bi.BlockDefinitionHandle + FileConstants.COMMA + bi.Layer;
								//DTMPoint (insertion point location; match this on read using the dictionary thing)
								outstring += FileConstants.COMMA + point.X.ToString() + FileConstants.COMMA + point.Y.ToString() + FileConstants.COMMA + point.Z.ToString();
								//Insertion Offset
								outstring += FileConstants.COMMA + bi.InsertionOffset.X.ToString() + FileConstants.COMMA + bi.InsertionOffset.Y.ToString() + FileConstants.COMMA + bi.InsertionOffset.Z.ToString();
								//Scale
								outstring += FileConstants.COMMA + bi.Scale.X.ToString() + FileConstants.COMMA + bi.Scale.Y.ToString() + FileConstants.COMMA + bi.Scale.Z.ToString();
								//Rotation
								outstring += FileConstants.COMMA + bi.Rotation.ToString();
								//Colour (ARGB)
								outstring += FileConstants.COMMA + bi.Colour.ToArgb().ToString();

								writer.WriteLine(outstring);
							}
						}
					}

					writer.WriteLine(FileConstants.BLOCKINSERTSEND);
					writer.Flush();

				}
			}



			public  bool WriteFile(DTM ModelToWrite, string filename = "", string projectName = null)
			{
				#region legitimacy checks 
				//check that we have an instantiated models and it contains at least one point - otherwise fuck it off
				if (ModelToWrite == null || ModelToWrite.Points == null || ModelToWrite.Points.Count <= 0)
				{
					MessageBox.Show("The file cannot be saved as there is no data.", "NRG File", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					return false;
				}
				//Quick sanity check on the filename
				if (filename == null || filename == "")
				{
					MessageBox.Show("The file cannot be saved as the file name is invalid.", "NRG File", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
					return false;

				}

				//Shit programming alert!!!
				//The following is a horrible hack, there must be a better way of doing this
				//Move this to a generic place
				foreach (char c in Path.GetInvalidPathChars())
				{
					if (filename.Contains(c))
					{
						MessageBox.Show("The file cannot be saved as the file name is invalid.", "NRG File", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
						return false;

					}
				}
				#endregion legitimacy checks 

				/*Okey Dokey - this is where the fun begins...
				I'm going to to put file section delimeters in square braces as no one uses them...errr
				No. 1 [HEADER]
				No. 2 [LAYERS]
				No. 3 [POINTS]
				No. 4 [TRIANGLES]
				No. 5 [PRESENTATION]
				No. 6 [FEATURES]
				No. 7 [POLYLINES]
				No. 8 [STANDARDLINES]
				Each file input line that begins with a double slash - just removed a thing that we used in BEGINNERS ALL SYMBOLIC INSTRUCTION CODE - which I could see causing problems
				*/



				StreamWriter filewriter = new StreamWriter(filename);

				NRGFileHeader header = new NRGFileHeader();

				header.SiteShift = new Point3D(0, 0, 0);

				header.User = System.Security.Principal.WindowsIdentity.GetCurrent().Name;

				if (string.IsNullOrEmpty(projectName))
				{
					projectName = "";
				}
				header.Contract = projectName;
				header.WriteHeader(filewriter);
				this.WriteLayers(ModelToWrite, filewriter);
				this.WriteSurfaces(ModelToWrite, filewriter);
				this.WritePoints(ModelToWrite, filewriter);
				this.WriteTriangles(ModelToWrite, filewriter);
				this.WriteFeaturesLibrary(ModelToWrite.FeaturesDictionary, filewriter);
				this.WritePolyLines(ModelToWrite, filewriter);
				this.WriteStandardLines(ModelToWrite, filewriter);
				this.WriteBlockDefinitions(ModelToWrite, filewriter);
				this.WriteBlockInserts(ModelToWrite, filewriter);

				filewriter.Dispose();
				return true;
			}

			
		}
	}


}
